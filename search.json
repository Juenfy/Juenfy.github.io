[{"title":"API接口设计","url":"/2025/05/22/API%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/","content":"API接口设计首先接口是不能裸奔的，不然你就BOOM了！！！首先接口是不能裸奔的，不然你就BOOM了！！！首先接口是不能裸奔的，不然你就BOOM了！！！一、那么接口一般面临三个安全问题\n请求身份是否合法\n请求参数是否被篡改\n请求是否唯一（重放攻击）\n\n二、那么针对这三个问题，怎么解决呢？？\n请求身份合法问题就用接口签名认证（sign）解决，需要登录才能操作的api还要验证用户的token\n请求参数篡改的问题就对入参除sign外的其他参数的key升序或者降序，再拼上api的加密密钥secretKey&#x3D;，然后用一个不可逆的加密算法，例如md5，这样就能得出sign\n请求的唯一问题就定义api必须传ts（时间戳）和nonce（随机唯一code）这两个参数，后端将nonce作为key用redis存起来，给一个过期时间，只要是在过期内重复请求就拦截\n\n这样下来，三个问题就能解决了，这是常规的接口认证方式！！！\n三、接下来就是CODING TIME首先我这里图个方便，api响应用了组件\ncomposer require sevming/laravel-response:^1.0\n涉及到接口拦截响应msg，code还有用到得缓存key这些建议都用枚举（enum）存放，还有api一般都有v1、v2…等不同版本，所以要做好目录结构。\n这是存放api拦截响应信息的枚举类\n&lt;?phpnamespace App\\Http\\Enums\\Api\\v1;class ApiResponseEnum&#123;    const DEFECT_SIGN = &#x27;缺失sign签名|10001&#x27;;    const DEFECT_TIMESTAMP = &#x27;缺失ts时间戳|10002&#x27;;    const DEFECT_NONCE = &#x27;缺失nonce|10003&#x27;;    const INVALID_SIGN = &#x27;非法sign签名|20001&#x27;;    const INVALID_TIMESTAMP = &#x27;非法ts时间戳|20002&#x27;;    const INVALID_NONCE = &#x27;非法请求|20003&#x27;;    const DEFECT_TOKEN = &#x27;缺失token|30001&#x27;;    const INVALID_TOKEN = &#x27;非法token|30002&#x27;;    const TWICE_PASSWORD_NOT_SAME = &#x27;两次密码不一致|40001&#x27;;    const ACCOUNT_HAS_REGISTER = &#x27;账号已注册|40002&#x27;;    const INVALID_EMAIL_FORMAT = &#x27;邮箱格式不对|40003&#x27;;    const INVALID_PASSWORD_LENGTH = &#x27;密码至少8位|40004&#x27;;    const WEI_CODE_HAS_REGISTER = &#x27;微聊号已注册|40005&#x27;;    const REGISTER_ERROR = &#x27;注册失败|40006&#x27;;    const ACCOUNT_NOT_EXISTS = &#x27;账号不存在|40007&#x27;;    const ACCOUNT_HAS_BAN = &#x27;账号已被封禁|40008&#x27;;    const INVALID_PASSWORD = &#x27;密码错误|40009&#x27;;&#125;\n\n还有一个存放缓存key的\n&lt;?phpnamespace App\\Http\\Enums\\Api\\v1;//api 缓存KEY 枚举类class ApiCacheKeyEnum&#123;    const NONCE_CACHE_KEY = &#x27;api_request_nonce:&#x27;;    const TOKEN_CACHE_KEY = &#x27;user_token:&#x27;;&#125;\n\n关于api认证的设计\n设计思想：首先在api的基类中统一对接口入参做一个入参检测，也就是配置必传参数、设置默认值等，这样就不用在业务层中对参数做繁琐的判空处理。然后api认证及token校验的拦截用中间件去做。\n\n首先建一个api的配置文件（api.php），读.env里的配置，这里的params_check就是配置接口入参检测的，凡是配置的参数都是必传的，key是接口方法名（取决于路由，本人一般路由与接口方法名会保持一致）。这里不用表单验证器是因为本人觉得每个接口方法都要写一个表单验证实在繁琐，所以改成了这种配置的方式。\n\n&lt;?phpuse App\\Http\\Controllers\\Api\\BaseApi;return [    &#x27;v1&#x27; =&gt; [        &#x27;api_key&#x27; =&gt; env(&#x27;API_KEY_V1&#x27;),//api sign加密密钥        &#x27;user_key&#x27; =&gt; env(&#x27;USER_KEY_V1&#x27;),//用户token加密密钥,        //接口入参检测        &#x27;params_check&#x27; =&gt; [            &#x27;_register&#x27; =&gt; [                &#x27;name&#x27; =&gt; [                    &#x27;type&#x27; =&gt; BaseApi::PARAM_STRING,//入参类型                    &#x27;default&#x27; =&gt; &#x27;user&#x27; . uniqid()//默认值                ],                &#x27;email&#x27; =&gt; BaseApi::PARAM_STRING,                &#x27;password&#x27; =&gt; BaseApi::PARAM_STRING,                &#x27;confirm_password&#x27; =&gt; BaseApi::PARAM_STRING            ],            &#x27;_login&#x27; =&gt; [                &#x27;email&#x27; =&gt; BaseApi::PARAM_STRING,                &#x27;password&#x27; =&gt; BaseApi::PARAM_STRING            ]        ]    ],];\n\napi基类的实现（BaseApi）\n\n&lt;?phpnamespace App\\Http\\Controllers\\Api;use App\\Http\\Enums\\Api\\v1\\ApiCacheKeyEnum;use Sevming\\LaravelResponse\\Support\\Facades\\Response;use Illuminate\\Support\\Facades\\Redis;class BaseApi&#123;    const PARAM_INT = 1;//整型    const PARAM_STRING = 2;//字符串    const PARAM_ARRAY = 3;//数组    const PARAM_FILE = 4;//文件    protected $params;    public function __construct()    &#123;        //入参检测，并初始化入参        $this-&gt;params = $this-&gt;check_params();    &#125;    //api接口统一入参检测    public function check_params()    &#123;        $action_list = explode(&#x27;/&#x27;, \\request()-&gt;path());        $params_check_key = end($action_list);        //入参检测配置        $params_check = config(&#x27;api.v1.params_check.&#x27; . $params_check_key);        //入参        $params = request()-&gt;input();        if (is_array($params_check) &amp;&amp; $params_check) &#123;            $flag = true;            foreach ($params_check as $key =&gt; $check) &#123;                if (is_array($check)) &#123;                    $type = $check[&#x27;type&#x27;] ?? 2;//默认是字符串                    $default = $check[&#x27;default&#x27;] ?? &#x27;&#x27;;//默认值                &#125; else &#123;                    $type = $check;                &#125;                if (array_key_exists($key, $params)) &#123;                    switch ($type) &#123;                        case self::PARAM_INT:                            $flag = is_numeric($params[$key]) || (isset($default) &amp;&amp; empty($params[$key]));                            break;                        case self::PARAM_STRING:                            $flag = is_string($params[$key]) || (isset($default) &amp;&amp; empty($params[$key]));                            break;                        case self::PARAM_ARRAY:                            $flag = is_array($params[$key]) || (isset($default) &amp;&amp; empty($params[$key]));                            break;                        case self::PARAM_FILE:                            $flag = $_FILES[$key] &amp;&amp; isset($_FILES[$key][&#x27;error&#x27;]) &amp;&amp; $_FILES[$key][&#x27;error&#x27;] == 0;                            break;                    &#125;                &#125; else &#123;                    $flag = false;                &#125;                if (!$flag) &#123;                    return Response::fail(&#x27;invalid param &#x27; . $key);                &#125;                //默认值处理                if (empty($params[$key]) &amp;&amp; isset($default)) &#123;                    $params[$key] = $default;                &#125;                //文件处理                if ($type === BaseApi::PARAM_FILE) &#123;                    $params[$key] = $_FILES[$key];                &#125;                unset($default);            &#125;        &#125;        //根据token获取uid        if (array_key_exists(&#x27;token&#x27;, $params)) &#123;            //获取uid            $redis = Redis::connection();            $uid = $redis-&gt;get(ApiCacheKeyEnum::TOKEN_CACHE_KEY . $params[&#x27;token&#x27;]);            $params[&#x27;uid&#x27;] = $uid ?? 0;            unset($params[&#x27;token&#x27;]);        &#125;        unset($params[&#x27;sign&#x27;]);        return $params;    &#125;&#125;\n\n\n用到的一些公共函数放到common.php中，这个看习惯\n\n&lt;?php//公共函数if (!function_exists(&#x27;make_sign&#x27;)) &#123;    //生成签名    function make_sign($params)    &#123;        unset($params[&#x27;sign&#x27;]);        $params[&#x27;api_key&#x27;] = config(&#x27;api.v1.api_key&#x27;);//拼接api加密密钥        ksort($params);//key升序        $string_temp = http_build_query($params);        return md5($string_temp);    &#125;&#125;if (!function_exists(&#x27;encrypt_token&#x27;)) &#123;\t//生成token    function encrypt_token($uid)    &#123;        $user_info = [            &#x27;uid&#x27; =&gt; $uid,            &#x27;ts&#x27; =&gt; time()        ];        $user_key = config(&#x27;api.v1.user_key&#x27;);        return openssl_encrypt(base64_encode(json_encode($user_info)), &#x27;DES-ECB&#x27;, $user_key, 0);    &#125;&#125;if (!function_exists(&#x27;make_avatar&#x27;)) &#123;    function make_avatar($email)    &#123;        $md5_email = md5($email);        return &quot;https://api.multiavatar.com/&#123;$md5_email&#125;.png&quot;;    &#125;&#125;\n\n\nApi服务类实现接口的签名认证和token校验方法\n\n&lt;?phpnamespace App\\Http\\Contracts\\Api\\v1;interface ApiInterface&#123;    //api签名认证    public function checkSign($params);    //用户token校验    public function checkToken($params);&#125;\n\n&lt;?phpnamespace App\\Http\\Services\\Api\\v1;use App\\Http\\Contracts\\Api\\v1\\ApiInterface;use App\\Http\\Enums\\Api\\v1\\ApiCacheKeyEnum;use App\\Http\\Enums\\Api\\v1\\ApiResponseEnum;use Illuminate\\Support\\Facades\\Redis;use Sevming\\LaravelResponse\\Support\\Facades\\Response;class ApiService implements ApiInterface&#123;    public static $instance = null;    /**     * @return static|null     * 单例模式     */    public static function getInstance()    &#123;        if (is_null(self::$instance)) &#123;            self::$instance = new static();        &#125;        return self::$instance;    &#125;    /**     * @param $params array 入参     * 签名认证     */    public function checkSign($params)    &#123;        // TODO: Implement checkSign() method.        if (!isset($params[&#x27;sign&#x27;])) &#123;            return Response::fail(ApiResponseEnum::DEFECT_SIGN);        &#125;        if (!isset($params[&#x27;ts&#x27;])) &#123;            return Response::fail(ApiResponseEnum::DEFECT_TIMESTAMP);        &#125;        if (!isset($params[&#x27;nonce&#x27;])) &#123;            return Response::fail(ApiResponseEnum::DEFECT_NONCE);        &#125;        $ts = $params[&#x27;ts&#x27;];//时间戳        $nonce = $params[&#x27;nonce&#x27;];        $sign = $params[&#x27;sign&#x27;];        $time = time();        if ($ts &gt; $time) &#123;            return Response::fail(ApiResponseEnum::INVALID_TIMESTAMP);        &#125;        $redis = Redis::connection();        if ($redis-&gt;exists(ApiCacheKeyEnum::NONCE_CACHE_KEY . $nonce)) &#123;            return Response::fail(ApiResponseEnum::INVALID_NONCE);        &#125;        $api_sign = make_sign($params);        if ($api_sign !== $sign) &#123;            return Response::fail(ApiResponseEnum::INVALID_SIGN);        &#125;        //5分钟内一个sign不能重复请求，防止重放攻击        $redis-&gt;setex(ApiCacheKeyEnum::NONCE_CACHE_KEY . $nonce, 300, $time);        return true;    &#125;    /**     * @param $params     * TOKEN校验     */    public function checkToken($params)    &#123;        // TODO: Implement checkToken() method.        $action_list = explode(&#x27;/&#x27;, \\request()-&gt;path());        $action = end($action_list);        //带下划线的方法无需登录，直接放行        if (stripos($action, &#x27;_&#x27;)) &#123;            return true;        &#125;        if (!isset($params[&#x27;token&#x27;])) &#123;            return Response::fail(ApiResponseEnum::DEFECT_TOKEN);        &#125;        $token = $params[&#x27;token&#x27;];        //查缓存是否存在该登录用户token        $redis = Redis::connection();        $cache_token = $redis-&gt;get(ApiCacheKeyEnum::TOKEN_CACHE_KEY . $token);        if (!$cache_token) &#123;            return Response::fail(ApiResponseEnum::INVALID_TOKEN);        &#125;        return true;    &#125;&#125;\n\n\napi认证拦截的中间件\n\n&lt;?phpnamespace App\\Http\\Middleware;use App\\Http\\Services\\Api\\v1\\ApiService;use Closure;class ApiIntercept&#123;    public function handle($request, Closure $next)    &#123;        $params = $request-&gt;input();        $env = config(&#x27;env&#x27;);        if ($env !== &#x27;local&#x27;) &#123;            //非本地环境，需要签名认证            ApiService::getInstance()-&gt;checkSign($params);        &#125;        //token检验        ApiService::getInstance()-&gt;checkToken($params);        return $next($request);    &#125;&#125;\n\n\n四、下面以简单的登录注册为例子\nUser模型类\n\n&lt;?php/** * User: yanjianfei * Date: 2021/9/18 * Time: 10:17 */namespace App\\Model;use App\\Http\\Enums\\Api\\v1\\ApiCacheKeyEnum;use App\\Http\\Enums\\Api\\v1\\ApiResponseEnum;use Illuminate\\Support\\Facades\\Redis;use Sevming\\LaravelResponse\\Support\\Facades\\Response;class User extends BaseModel&#123;\t//注册    public function checkRegister($params)    &#123;        if ($params[&#x27;password&#x27;] !== $params[&#x27;confirm_password&#x27;]) &#123;            return Response::fail(ApiResponseEnum::TWICE_PASSWORD_NOT_SAME);        &#125;        if (strlen($params[&#x27;password&#x27;]) &lt; 8) &#123;            return Response::fail(ApiResponseEnum::INVALID_PASSWORD_LENGTH);        &#125;        $pattern = &#x27;^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$&#x27;;        if (preg_match($pattern, $params[&#x27;email&#x27;])) &#123;            return Response::fail(ApiResponseEnum::INVALID_EMAIL_FORMAT);        &#125;        $account_exits = self::query()-&gt;where(&#x27;email&#x27;, $params[&#x27;email&#x27;])-&gt;exists();        if ($account_exits) &#123;            return Response::fail(ApiResponseEnum::ACCOUNT_HAS_REGISTER);        &#125;        $wei_code_exists = self::query()-&gt;where(&#x27;wei_code&#x27;, $params[&#x27;wei_code&#x27;])-&gt;exists();        if ($wei_code_exists) &#123;            return Response::fail(ApiResponseEnum::WEI_CODE_HAS_REGISTER);        &#125;        $data = [            &#x27;name&#x27; =&gt; $params[&#x27;name&#x27;],            &#x27;password&#x27; =&gt; md5($params[&#x27;password&#x27;]),            &#x27;avatar&#x27; =&gt; make_avatar($params[&#x27;email&#x27;]),            &#x27;email&#x27; =&gt; $params[&#x27;email&#x27;]        ];        $user = self::query()-&gt;create($data);        if (!$user) &#123;            return Response::fail();        &#125;\t\t//注册完后自动登录        return $this-&gt;checkLogin($user, true);    &#125;    /**     * @param $params     * @param false $auto 自动登录     */    public function checkLogin($params, $auto = false)    &#123;        $user = $params;        if (!$auto) &#123;            $user = self::query()-&gt;where(&#x27;email&#x27;, $params[&#x27;email&#x27;])-&gt;first();            if (!$user) &#123;                return Response::fail(ApiResponseEnum::ACCOUNT_NOT_EXISTS);            &#125;            if ($user[&#x27;status&#x27;] == 0) &#123;                return Response::fail(ApiResponseEnum::ACCOUNT_HAS_BAN);            &#125;            if ($user[&#x27;password&#x27;] !== md5($params[&#x27;password&#x27;])) &#123;                return Response::fail(ApiResponseEnum::INVALID_PASSWORD);            &#125;        &#125;        $token = encrypt_token($user[&#x27;id&#x27;]);//生成token        $redis = Redis::connection();        $redis-&gt;setex(ApiCacheKeyEnum::TOKEN_CACHE_KEY . $token, 86400, $user[&#x27;id&#x27;]);//reids存放token        return [            &#x27;token&#x27; =&gt; $token,            &#x27;name&#x27; =&gt; $user[&#x27;name&#x27;],            &#x27;avatar&#x27; =&gt; $user[&#x27;avatar&#x27;]        ];//返回登录信息    &#125;&#125;````2. User控制器```php&lt;?php/** * User: yanjianfei * Date: 2021/9/17 * Time: 17:01 */namespace App\\Http\\Controllers\\Api\\v1;use App\\Http\\Controllers\\Api\\BaseApi;use Sevming\\LaravelResponse\\Support\\Facades\\Response;use App\\Model\\User as UserModel;class User extends BaseApi&#123;    public function _login(UserModel $user)    &#123;        $data = $user-&gt;checkLogin($this-&gt;params);        return Response::success($data);    &#125;    public function _register(UserModel $user)    &#123;        $data = $user-&gt;checkRegister($this-&gt;params);        return Response::success($data);    &#125;&#125;\n\n\n配置路由\n\n&lt;?php\n\n//用户路由\nRoute::group([\n    &#39;prefix&#39; =&gt; &#39;user&#39;,\n    &#39;namespace&#39; =&gt; &#39;Api\\v1&#39;,\n    &#39;middleware&#39; =&gt; &#39;api.intercept&#39;//api认证拦截中间件\n], function ($router) &#123;\n    $router-&gt;post(&#39;_login&#39;, &#39;User@_login&#39;);\n    $router-&gt;post(&#39;_register&#39;, &#39;User@_register&#39;);\n&#125;);\n\n到这里api的签名认证就已经设计开发好了！！！感谢观看！！！\n","categories":["后端"],"tags":["PHP","Laravel"]},{"title":"前端评论组件","url":"/2025/05/22/%E5%89%8D%E7%AB%AF%E8%AF%84%E8%AE%BA%E7%BB%84%E4%BB%B6/","content":"搞了个评论组件，样式抄vx的:grin:支持扩展表情包、自带了一些支持发送文本支持发语音后面有人用再更新一下功能！！！github：https://github.com/Juenfy/vue-wechat-comment\n","categories":["前端"],"tags":["npm包"]},{"title":"前端音视频通话组件","url":"/2025/05/22/%E5%89%8D%E7%AB%AF%E9%9F%B3%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D%E7%BB%84%E4%BB%B6/","content":"服务端nodejs，客户端vue3，通过websocket通讯暂时只支持一对一通话传送门：https://github.com/Juenfy/vue-av-call帮忙点个star呗!\n\n    \n\t\n\n\n","categories":["前端"],"tags":["npm包"]},{"title":"基于WebRTC实现音视频通话","url":"/2025/05/22/%E5%9F%BA%E4%BA%8EWebRTC%E5%AE%9E%E7%8E%B0%E9%9F%B3%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D/","content":"WebRTC实现音视频通话最近闲暇时间（摸鱼时间很难熬）都在搞这个仿微信的项目，于是乎今天就接了个音视频通话。在线体验：https://chat.juenfy.cn已存在用户：13006789001~13006789010 密码都是123456前端项目github:https://github.com/Juenfy/cover-wechat-client后端项目github:https://github.com/Juenfy/cover-wechat-api\n客户端采用WebRTC技术（推流），通讯用websocket。\nWebRTC像是一个面试过程：第一步：拨打电话发起方（拨打电话者）点击拨打电话时，获取本地媒体流并推流给接收方同时捕获接收方推过来的流，捕获到后把流设置到dom上，监听ICE候选确保能点对连接，生成offer，通过websocket告知接收方并拉起等待接听界面。\n//获取媒体流stream.value = await navigator.mediaDevices.getUserMedia(&#123;\tvideo: true,\taudio: true&#125;);// 初始化 PeerConnectionpeerConnection.value = new RTCPeerConnection(&#123;    iceServers: [        &#123;            urls: &#x27;stun:stun.l.google.com:19302&#x27;        &#125;    ]&#125;);// 推流给接收方stream.value.getTracks().forEach((track) =&gt; &#123;\tpeerConnection.value.addTrack(track, stream.value);&#125;);// 捕获接收方的流peerConnection.value.ontrack = (event) =&gt; &#123;\tremoteStream.value = event.streams[0];\tif (callType.value === TypeVideo) &#123;\t\tremoteVideo.value.srcObject = remoteStream.value;\t&#125; else &#123;\t\tremoteAudio.value.srcObject = remoteStream.value;\t&#125;&#125;;// 监听ICE候选，确保 WebRTC 的点对点连接能够成功建立peerConnection.value.onicecandidate = (event) =&gt; &#123;\tif (event.candidate) &#123;\t\t//发送candidate\t\tws.send(event.candidate);\t&#125;&#125;;// 创建 offerconst offer = await peerConnection.value.createOffer();await peerConnection.value.setLocalDescription(offer);//发送offer，这里发送的offer可以理解成是接收方用来捕获发起方流的一个凭证，接收方通过peerConnection.value.ontrack可以捕获到。ws.send(offer);//拉起等待接听界面showCall.value = true;//状态等待接听callStatus.value = &#x27;wating&#x27;;\n\n第二步：接收电话接收方收到offer后，先拉起来电界面，再选择接听或者挂断。\n1）拉起来电接听界面//拉起来电接听界面showCall.vue = true;//状态来电接听callStatus.value = &#x27;coming&#x27;;//初始化来电人信息等....\n2）挂断告诉发起方我挂断了，发起方就把RTC关掉、停止推流，dom置空就好了\n//接收方showCall.value = false;callStatus.value = &#x27;closing&#x27;;ws.send(&#x27;reject&#x27;);//发起方if (peerConnection.value) &#123;\tpeerConnection.value.close();\tpeerConnection.value = null;&#125;if (stream.value) &#123;\tconst tracks = stream.value.getTracks();\ttracks.forEach((track) =&gt; track.stop());&#125;if (localVideo.value)\tlocalVideo.value.srcObject = null;if (remoteVideo.value)\tremoteVideo.value.srcObject = null;if (remoteAudio.value)\tremoteAudio.value.srcObject = null;showCall.value = false;callStatus.value = &#x27;closing&#x27;;\n\n2）或者接听操作跟拨打流程差不多，需要设置远端SDP（发起方的offer)，添加ICE候选（发起方的ice，这里需要注意的是只有远端SDP初始化完毕状态下才能设置ice）\n// 获取本地媒体流...同发起方// 初始化 PeerConnection...同发起方// 推流给发起方...同发起方// 捕获发起方的流...同发起方// 监听ICE候选...同发起方//设置远端SDPawait peerConnection.value.setRemoteDescription(new RTCSessionDescription(caller.value.offer));// 添加发起方发过来的iceiceCandidateQueue.value.forEach(async (candidate) =&gt; &#123;await  peerConnection.value.addIceCandidate(candidate);&#125;);iceCandidateQueue.value  = [];// 创建 answerconst  answer  =  await  peerConnection.value.createAnswer();await  peerConnection.value.setLocalDescription(answer);//发送answer给发起方ws.send(answer);//状态通话中callStatus.value = &#x27;calling&#x27;;\n关于ice的处理，就是远端SDP初始化完毕状态可以直接设置，未初始化完毕就存到iceCandidateQueue队列备用\n// 处理新的 ICE 候选const handleNewICECandidate = async (candidate) =&gt; &#123;    const iceCandidate = new RTCIceCandidate(candidate);    if (peerConnection.value?.signalingState === &#x27;have-remote-offer&#x27; || peerConnection.value?.signalingState === &#x27;stable&#x27;) &#123;        peerConnection.value.addIceCandidate(iceCandidate);    &#125; else &#123;        iceCandidateQueue.value.push(iceCandidate);    &#125;&#125;;\n3）设置远端SDP、ICE发起方收到接收方的答复（接收方接听了），设置远端SDP（接收方的answer）,设置ICE（接收方的ice）\n//设置远端SDPawait peerConnection.value.setRemoteDescription(new RTCSessionDescription(caller.value.answer));//添加ICEiceCandidateQueue.value.forEach(async (candidate) =&gt; &#123;\tawait peerConnection.value.addIceCandidate(candidate);&#125;);iceCandidateQueue.value = [];//状态接听中callStatus.value = &#x27;calling&#x27;;\n\n这就是WebRTC视频通话的关键代码跟流程！\n我的项目实现效果图：\n\n    \n\t\n\t\n","categories":["前端"],"tags":["WebRTC"]}]