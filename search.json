[{"title":"API接口设计","url":"/2025/05/22/API%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/","content":"API接口设计首先接口是不能裸奔的，不然你就BOOM了！！！首先接口是不能裸奔的，不然你就BOOM了！！！首先接口是不能裸奔的，不然你就BOOM了！！！一、那么接口一般面临三个安全问题\n请求身份是否合法\n请求参数是否被篡改\n请求是否唯一（重放攻击）\n\n二、那么针对这三个问题，怎么解决呢？？\n请求身份合法问题就用接口签名认证（sign）解决，需要登录才能操作的api还要验证用户的token\n请求参数篡改的问题就对入参除sign外的其他参数的key升序或者降序，再拼上api的加密密钥secretKey&#x3D;，然后用一个不可逆的加密算法，例如md5，这样就能得出sign\n请求的唯一问题就定义api必须传ts（时间戳）和nonce（随机唯一code）这两个参数，后端将nonce作为key用redis存起来，给一个过期时间，只要是在过期内重复请求就拦截\n\n这样下来，三个问题就能解决了，这是常规的接口认证方式！！！\n三、接下来就是CODING TIME首先我这里图个方便，api响应用了组件\ncomposer require sevming/laravel-response:^1.0\n涉及到接口拦截响应msg，code还有用到得缓存key这些建议都用枚举（enum）存放，还有api一般都有v1、v2…等不同版本，所以要做好目录结构。\n这是存放api拦截响应信息的枚举类\n&lt;?phpnamespace App\\Http\\Enums\\Api\\v1;class ApiResponseEnum&#123;    const DEFECT_SIGN = &#x27;缺失sign签名|10001&#x27;;    const DEFECT_TIMESTAMP = &#x27;缺失ts时间戳|10002&#x27;;    const DEFECT_NONCE = &#x27;缺失nonce|10003&#x27;;    const INVALID_SIGN = &#x27;非法sign签名|20001&#x27;;    const INVALID_TIMESTAMP = &#x27;非法ts时间戳|20002&#x27;;    const INVALID_NONCE = &#x27;非法请求|20003&#x27;;    const DEFECT_TOKEN = &#x27;缺失token|30001&#x27;;    const INVALID_TOKEN = &#x27;非法token|30002&#x27;;    const TWICE_PASSWORD_NOT_SAME = &#x27;两次密码不一致|40001&#x27;;    const ACCOUNT_HAS_REGISTER = &#x27;账号已注册|40002&#x27;;    const INVALID_EMAIL_FORMAT = &#x27;邮箱格式不对|40003&#x27;;    const INVALID_PASSWORD_LENGTH = &#x27;密码至少8位|40004&#x27;;    const WEI_CODE_HAS_REGISTER = &#x27;微聊号已注册|40005&#x27;;    const REGISTER_ERROR = &#x27;注册失败|40006&#x27;;    const ACCOUNT_NOT_EXISTS = &#x27;账号不存在|40007&#x27;;    const ACCOUNT_HAS_BAN = &#x27;账号已被封禁|40008&#x27;;    const INVALID_PASSWORD = &#x27;密码错误|40009&#x27;;&#125;\n\n还有一个存放缓存key的\n&lt;?phpnamespace App\\Http\\Enums\\Api\\v1;//api 缓存KEY 枚举类class ApiCacheKeyEnum&#123;    const NONCE_CACHE_KEY = &#x27;api_request_nonce:&#x27;;    const TOKEN_CACHE_KEY = &#x27;user_token:&#x27;;&#125;\n\n关于api认证的设计\n设计思想：首先在api的基类中统一对接口入参做一个入参检测，也就是配置必传参数、设置默认值等，这样就不用在业务层中对参数做繁琐的判空处理。然后api认证及token校验的拦截用中间件去做。\n\n首先建一个api的配置文件（api.php），读.env里的配置，这里的params_check就是配置接口入参检测的，凡是配置的参数都是必传的，key是接口方法名（取决于路由，本人一般路由与接口方法名会保持一致）。这里不用表单验证器是因为本人觉得每个接口方法都要写一个表单验证实在繁琐，所以改成了这种配置的方式。\n\n&lt;?phpuse App\\Http\\Controllers\\Api\\BaseApi;return [    &#x27;v1&#x27; =&gt; [        &#x27;api_key&#x27; =&gt; env(&#x27;API_KEY_V1&#x27;),//api sign加密密钥        &#x27;user_key&#x27; =&gt; env(&#x27;USER_KEY_V1&#x27;),//用户token加密密钥,        //接口入参检测        &#x27;params_check&#x27; =&gt; [            &#x27;_register&#x27; =&gt; [                &#x27;name&#x27; =&gt; [                    &#x27;type&#x27; =&gt; BaseApi::PARAM_STRING,//入参类型                    &#x27;default&#x27; =&gt; &#x27;user&#x27; . uniqid()//默认值                ],                &#x27;email&#x27; =&gt; BaseApi::PARAM_STRING,                &#x27;password&#x27; =&gt; BaseApi::PARAM_STRING,                &#x27;confirm_password&#x27; =&gt; BaseApi::PARAM_STRING            ],            &#x27;_login&#x27; =&gt; [                &#x27;email&#x27; =&gt; BaseApi::PARAM_STRING,                &#x27;password&#x27; =&gt; BaseApi::PARAM_STRING            ]        ]    ],];\n\napi基类的实现（BaseApi）\n\n&lt;?phpnamespace App\\Http\\Controllers\\Api;use App\\Http\\Enums\\Api\\v1\\ApiCacheKeyEnum;use Sevming\\LaravelResponse\\Support\\Facades\\Response;use Illuminate\\Support\\Facades\\Redis;class BaseApi&#123;    const PARAM_INT = 1;//整型    const PARAM_STRING = 2;//字符串    const PARAM_ARRAY = 3;//数组    const PARAM_FILE = 4;//文件    protected $params;    public function __construct()    &#123;        //入参检测，并初始化入参        $this-&gt;params = $this-&gt;check_params();    &#125;    //api接口统一入参检测    public function check_params()    &#123;        $action_list = explode(&#x27;/&#x27;, \\request()-&gt;path());        $params_check_key = end($action_list);        //入参检测配置        $params_check = config(&#x27;api.v1.params_check.&#x27; . $params_check_key);        //入参        $params = request()-&gt;input();        if (is_array($params_check) &amp;&amp; $params_check) &#123;            $flag = true;            foreach ($params_check as $key =&gt; $check) &#123;                if (is_array($check)) &#123;                    $type = $check[&#x27;type&#x27;] ?? 2;//默认是字符串                    $default = $check[&#x27;default&#x27;] ?? &#x27;&#x27;;//默认值                &#125; else &#123;                    $type = $check;                &#125;                if (array_key_exists($key, $params)) &#123;                    switch ($type) &#123;                        case self::PARAM_INT:                            $flag = is_numeric($params[$key]) || (isset($default) &amp;&amp; empty($params[$key]));                            break;                        case self::PARAM_STRING:                            $flag = is_string($params[$key]) || (isset($default) &amp;&amp; empty($params[$key]));                            break;                        case self::PARAM_ARRAY:                            $flag = is_array($params[$key]) || (isset($default) &amp;&amp; empty($params[$key]));                            break;                        case self::PARAM_FILE:                            $flag = $_FILES[$key] &amp;&amp; isset($_FILES[$key][&#x27;error&#x27;]) &amp;&amp; $_FILES[$key][&#x27;error&#x27;] == 0;                            break;                    &#125;                &#125; else &#123;                    $flag = false;                &#125;                if (!$flag) &#123;                    return Response::fail(&#x27;invalid param &#x27; . $key);                &#125;                //默认值处理                if (empty($params[$key]) &amp;&amp; isset($default)) &#123;                    $params[$key] = $default;                &#125;                //文件处理                if ($type === BaseApi::PARAM_FILE) &#123;                    $params[$key] = $_FILES[$key];                &#125;                unset($default);            &#125;        &#125;        //根据token获取uid        if (array_key_exists(&#x27;token&#x27;, $params)) &#123;            //获取uid            $redis = Redis::connection();            $uid = $redis-&gt;get(ApiCacheKeyEnum::TOKEN_CACHE_KEY . $params[&#x27;token&#x27;]);            $params[&#x27;uid&#x27;] = $uid ?? 0;            unset($params[&#x27;token&#x27;]);        &#125;        unset($params[&#x27;sign&#x27;]);        return $params;    &#125;&#125;\n\n\n用到的一些公共函数放到common.php中，这个看习惯\n\n&lt;?php//公共函数if (!function_exists(&#x27;make_sign&#x27;)) &#123;    //生成签名    function make_sign($params)    &#123;        unset($params[&#x27;sign&#x27;]);        $params[&#x27;api_key&#x27;] = config(&#x27;api.v1.api_key&#x27;);//拼接api加密密钥        ksort($params);//key升序        $string_temp = http_build_query($params);        return md5($string_temp);    &#125;&#125;if (!function_exists(&#x27;encrypt_token&#x27;)) &#123;\t//生成token    function encrypt_token($uid)    &#123;        $user_info = [            &#x27;uid&#x27; =&gt; $uid,            &#x27;ts&#x27; =&gt; time()        ];        $user_key = config(&#x27;api.v1.user_key&#x27;);        return openssl_encrypt(base64_encode(json_encode($user_info)), &#x27;DES-ECB&#x27;, $user_key, 0);    &#125;&#125;if (!function_exists(&#x27;make_avatar&#x27;)) &#123;    function make_avatar($email)    &#123;        $md5_email = md5($email);        return &quot;https://api.multiavatar.com/&#123;$md5_email&#125;.png&quot;;    &#125;&#125;\n\n\nApi服务类实现接口的签名认证和token校验方法\n\n&lt;?phpnamespace App\\Http\\Contracts\\Api\\v1;interface ApiInterface&#123;    //api签名认证    public function checkSign($params);    //用户token校验    public function checkToken($params);&#125;\n\n&lt;?phpnamespace App\\Http\\Services\\Api\\v1;use App\\Http\\Contracts\\Api\\v1\\ApiInterface;use App\\Http\\Enums\\Api\\v1\\ApiCacheKeyEnum;use App\\Http\\Enums\\Api\\v1\\ApiResponseEnum;use Illuminate\\Support\\Facades\\Redis;use Sevming\\LaravelResponse\\Support\\Facades\\Response;class ApiService implements ApiInterface&#123;    public static $instance = null;    /**     * @return static|null     * 单例模式     */    public static function getInstance()    &#123;        if (is_null(self::$instance)) &#123;            self::$instance = new static();        &#125;        return self::$instance;    &#125;    /**     * @param $params array 入参     * 签名认证     */    public function checkSign($params)    &#123;        // TODO: Implement checkSign() method.        if (!isset($params[&#x27;sign&#x27;])) &#123;            return Response::fail(ApiResponseEnum::DEFECT_SIGN);        &#125;        if (!isset($params[&#x27;ts&#x27;])) &#123;            return Response::fail(ApiResponseEnum::DEFECT_TIMESTAMP);        &#125;        if (!isset($params[&#x27;nonce&#x27;])) &#123;            return Response::fail(ApiResponseEnum::DEFECT_NONCE);        &#125;        $ts = $params[&#x27;ts&#x27;];//时间戳        $nonce = $params[&#x27;nonce&#x27;];        $sign = $params[&#x27;sign&#x27;];        $time = time();        if ($ts &gt; $time) &#123;            return Response::fail(ApiResponseEnum::INVALID_TIMESTAMP);        &#125;        $redis = Redis::connection();        if ($redis-&gt;exists(ApiCacheKeyEnum::NONCE_CACHE_KEY . $nonce)) &#123;            return Response::fail(ApiResponseEnum::INVALID_NONCE);        &#125;        $api_sign = make_sign($params);        if ($api_sign !== $sign) &#123;            return Response::fail(ApiResponseEnum::INVALID_SIGN);        &#125;        //5分钟内一个sign不能重复请求，防止重放攻击        $redis-&gt;setex(ApiCacheKeyEnum::NONCE_CACHE_KEY . $nonce, 300, $time);        return true;    &#125;    /**     * @param $params     * TOKEN校验     */    public function checkToken($params)    &#123;        // TODO: Implement checkToken() method.        $action_list = explode(&#x27;/&#x27;, \\request()-&gt;path());        $action = end($action_list);        //带下划线的方法无需登录，直接放行        if (stripos($action, &#x27;_&#x27;)) &#123;            return true;        &#125;        if (!isset($params[&#x27;token&#x27;])) &#123;            return Response::fail(ApiResponseEnum::DEFECT_TOKEN);        &#125;        $token = $params[&#x27;token&#x27;];        //查缓存是否存在该登录用户token        $redis = Redis::connection();        $cache_token = $redis-&gt;get(ApiCacheKeyEnum::TOKEN_CACHE_KEY . $token);        if (!$cache_token) &#123;            return Response::fail(ApiResponseEnum::INVALID_TOKEN);        &#125;        return true;    &#125;&#125;\n\n\napi认证拦截的中间件\n\n&lt;?phpnamespace App\\Http\\Middleware;use App\\Http\\Services\\Api\\v1\\ApiService;use Closure;class ApiIntercept&#123;    public function handle($request, Closure $next)    &#123;        $params = $request-&gt;input();        $env = config(&#x27;env&#x27;);        if ($env !== &#x27;local&#x27;) &#123;            //非本地环境，需要签名认证            ApiService::getInstance()-&gt;checkSign($params);        &#125;        //token检验        ApiService::getInstance()-&gt;checkToken($params);        return $next($request);    &#125;&#125;\n\n\n四、下面以简单的登录注册为例子\nUser模型类\n\n&lt;?php/** * User: yanjianfei * Date: 2021/9/18 * Time: 10:17 */namespace App\\Model;use App\\Http\\Enums\\Api\\v1\\ApiCacheKeyEnum;use App\\Http\\Enums\\Api\\v1\\ApiResponseEnum;use Illuminate\\Support\\Facades\\Redis;use Sevming\\LaravelResponse\\Support\\Facades\\Response;class User extends BaseModel&#123;\t//注册    public function checkRegister($params)    &#123;        if ($params[&#x27;password&#x27;] !== $params[&#x27;confirm_password&#x27;]) &#123;            return Response::fail(ApiResponseEnum::TWICE_PASSWORD_NOT_SAME);        &#125;        if (strlen($params[&#x27;password&#x27;]) &lt; 8) &#123;            return Response::fail(ApiResponseEnum::INVALID_PASSWORD_LENGTH);        &#125;        $pattern = &#x27;^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$&#x27;;        if (preg_match($pattern, $params[&#x27;email&#x27;])) &#123;            return Response::fail(ApiResponseEnum::INVALID_EMAIL_FORMAT);        &#125;        $account_exits = self::query()-&gt;where(&#x27;email&#x27;, $params[&#x27;email&#x27;])-&gt;exists();        if ($account_exits) &#123;            return Response::fail(ApiResponseEnum::ACCOUNT_HAS_REGISTER);        &#125;        $wei_code_exists = self::query()-&gt;where(&#x27;wei_code&#x27;, $params[&#x27;wei_code&#x27;])-&gt;exists();        if ($wei_code_exists) &#123;            return Response::fail(ApiResponseEnum::WEI_CODE_HAS_REGISTER);        &#125;        $data = [            &#x27;name&#x27; =&gt; $params[&#x27;name&#x27;],            &#x27;password&#x27; =&gt; md5($params[&#x27;password&#x27;]),            &#x27;avatar&#x27; =&gt; make_avatar($params[&#x27;email&#x27;]),            &#x27;email&#x27; =&gt; $params[&#x27;email&#x27;]        ];        $user = self::query()-&gt;create($data);        if (!$user) &#123;            return Response::fail();        &#125;\t\t//注册完后自动登录        return $this-&gt;checkLogin($user, true);    &#125;    /**     * @param $params     * @param false $auto 自动登录     */    public function checkLogin($params, $auto = false)    &#123;        $user = $params;        if (!$auto) &#123;            $user = self::query()-&gt;where(&#x27;email&#x27;, $params[&#x27;email&#x27;])-&gt;first();            if (!$user) &#123;                return Response::fail(ApiResponseEnum::ACCOUNT_NOT_EXISTS);            &#125;            if ($user[&#x27;status&#x27;] == 0) &#123;                return Response::fail(ApiResponseEnum::ACCOUNT_HAS_BAN);            &#125;            if ($user[&#x27;password&#x27;] !== md5($params[&#x27;password&#x27;])) &#123;                return Response::fail(ApiResponseEnum::INVALID_PASSWORD);            &#125;        &#125;        $token = encrypt_token($user[&#x27;id&#x27;]);//生成token        $redis = Redis::connection();        $redis-&gt;setex(ApiCacheKeyEnum::TOKEN_CACHE_KEY . $token, 86400, $user[&#x27;id&#x27;]);//reids存放token        return [            &#x27;token&#x27; =&gt; $token,            &#x27;name&#x27; =&gt; $user[&#x27;name&#x27;],            &#x27;avatar&#x27; =&gt; $user[&#x27;avatar&#x27;]        ];//返回登录信息    &#125;&#125;````2. User控制器```php&lt;?php/** * User: yanjianfei * Date: 2021/9/17 * Time: 17:01 */namespace App\\Http\\Controllers\\Api\\v1;use App\\Http\\Controllers\\Api\\BaseApi;use Sevming\\LaravelResponse\\Support\\Facades\\Response;use App\\Model\\User as UserModel;class User extends BaseApi&#123;    public function _login(UserModel $user)    &#123;        $data = $user-&gt;checkLogin($this-&gt;params);        return Response::success($data);    &#125;    public function _register(UserModel $user)    &#123;        $data = $user-&gt;checkRegister($this-&gt;params);        return Response::success($data);    &#125;&#125;\n\n\n配置路由\n\n&lt;?php\n\n//用户路由\nRoute::group([\n    &#39;prefix&#39; =&gt; &#39;user&#39;,\n    &#39;namespace&#39; =&gt; &#39;Api\\v1&#39;,\n    &#39;middleware&#39; =&gt; &#39;api.intercept&#39;//api认证拦截中间件\n], function ($router) &#123;\n    $router-&gt;post(&#39;_login&#39;, &#39;User@_login&#39;);\n    $router-&gt;post(&#39;_register&#39;, &#39;User@_register&#39;);\n&#125;);\n\n到这里api的签名认证就已经设计开发好了！！！感谢观看！！！\n","categories":["后端"],"tags":["PHP","Laravel"]},{"title":"前端音视频通话组件","url":"/2025/05/22/%E5%89%8D%E7%AB%AF%E9%9F%B3%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D%E7%BB%84%E4%BB%B6/","content":"服务端nodejs，客户端vue3，通过websocket通讯暂时只支持一对一通话传送门：https://github.com/Juenfy/vue-av-call帮忙点个star呗!\n\n    \n\t\n\n\n","categories":["前端"],"tags":["npm包"]},{"title":"使用ffmpeg将mp4转换为加密m3u8","url":"/2025/05/29/%E4%BD%BF%E7%94%A8FFmpeg%E5%B0%86MP4%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8A%A0%E5%AF%86M3U8/","content":"使用ffmpeg将mp4转换为加密m3u8一、准备工作1.下载并安装ffmpeg确保已安装 FFmpeg 并添加到系统路径：\nffmpeg -version  # 验证安装\n2.生成密钥创建密钥文件 encrypt.key（16字节随机值）和密钥信息文件 keyinfo.txt：\n# 生成随机密钥（16字节）openssl rand 16 &gt; encrypt.key# 创建 keyinfo.txt（格式：密钥URL 密钥文件路径 IV）echo &quot;https://localhost/encrypt.key&quot; &gt; keyinfo.txtecho &quot;$(pwd)/encrypt.key&quot; &gt;&gt; keyinfo.txtecho &quot;0x$(openssl rand -hex 16)&quot; &gt;&gt; keyinfo.txt  # 随机初始化向量（IV）\n生成的keyinfo.txt文件内容如下：\nhttps://localhost/encrypt.keyD:\\phpstudy_pro\\WWW\\hello-muiplayer\\media\\encrypt.key0x259b1efb2769bfeef809378ceefa6c00\n请确保https://localhost/encrypt.key能够访问密钥文件\n二、ffmpeg转换命令1.执行命令（AES-128加密）# 单分辨加密率转换ffmpeg -i input.mp4 -c:v libx264 -c:a aac -f hls -hls_time 10 -hls_list_size 0 -hls_key_info_file keyinfo.txt -hls_segment_filename &quot;segment_%03d.ts&quot; playlist.m3u8\n\n\n\n参数\n作用\n\n\n\n-hls_time 10\n每10秒一个分片\n\n\nhls_list_size 0\n保留所有分片记录（适合点播）\n\n\n-hls_key_info_file keyinfo.txt\n指定密钥信息文件路径\n\n\n-hls_segment_filename &quot;segment_%03d.ts&quot;\n分片文件名模板（%03d 表示三位序号）\n\n\nplaylist.m3u8\n输出的播放列表文件名\n\n\n# 多分辨率加密转换ffmpeg -i input.mp4 -map 0:v:0 -map 0:a:0 -c:v:0 libx264 -b:v:0 2000k -s:0 1920x1080 -profile:v:0 main -c:a aac -b:a:0 128k -map 0:v:0 -map 0:a:0 -c:v:1 libx264 -b:v:1 1000k -s:1 1280x720 -profile:v:1 main -c:a aac -b:a:1 128k -map 0:v:0 -map 0:a:0 -c:v:2 libx264 -b:v:2 600k -s:2 854x480 -profile:v:2 main -c:a aac -b:a:2 128k -f hls -var_stream_map &quot;v:0,a:0 v:1,a:1 v:2,a:2&quot; -hls_time 10 -hls_list_size 0 -hls_segment_type mpegts -hls_key_info_file keyinfo.txt -master_pl_name &quot;master.m3u8&quot; -hls_segment_filename &quot;output_%v_%03d.ts&quot; &quot;output_%v.m3u8&quot;\n\n\n\n参数\n作用\n\n\n\n-map 0:v:0 -map 0:a:0\n映射输入文件的视频和音频流\n\n\n-s:0 1920x1080\n第一路分辨率（1080P）\n\n\n-b:v:0 2000k\n第一路视频码率（2Mbps）\n\n\n-var_stream_map &quot;v:0,a:0...&quot;\n指定每路流的音视频映射关系\n\n\n-hls_key_info_file keyinfo.txt\n指定加密密钥信息文件\n\n\n-master_pl_name &quot;master.m3u8&quot;\n生成主播放列表（包含多码率信息）\n\n\noutput_%v_%03d.ts\n分片文件名模板（%v&#x3D;流索引，%03d&#x3D;分片序号）\n\n\n2.如果执行遇到下面的报错问题[crypto @ 000001cf11949440] Error setting option encryption_iv to value 0x259b1efb2769bfeef809378ceefa6c.[hls @ 000001cf0c85e540] Failed to open file &#x27;crypto:segment_000.ts&#x27;[vost#0:0/libx264 @ 000001cf0c9b7040] Error submitting a packet to the muxer: Invalid argument    Last message repeated 1 times[out#0/hls @ 000001cf0a9e1480] Error muxing a packet[out#0/hls @ 000001cf0a9e1480] Task finished with error code: -22 (Invalid argument)[out#0/hls @ 000001cf0a9e1480] Terminating thread with return code -22 (Invalid argument)[hls @ 000001cf0c85e540] Opening &#x27;crypto:segment_000.ts&#x27; for writing[crypto @ 000001cf2fa75700] Error setting option encryption_iv to value 0x259b1efb2769bfeef809378ceefa6c.[hls @ 000001cf0c85e540] Failed to open file &#x27;segment_000.ts&#x27;\n解决方法：把keyinfo.txt文件里的随机初始化向量（IV）：0x259b1efb2769bfeef809378ceefa6c00改为259b1efb2769bfeef809378ceefa6c00，原因是有的工具不需要0x开头的16进制数，改完后再执行转换命令即可\n到这里就可以正常转换了。\n","categories":["教程"],"tags":["ffmpeg","m3u8"]},{"title":"前端评论组件","url":"/2025/05/22/%E5%89%8D%E7%AB%AF%E8%AF%84%E8%AE%BA%E7%BB%84%E4%BB%B6/","content":"搞了个评论组件，样式抄vx的:grin:支持扩展表情包、自带了一些支持发送文本支持发语音后面有人用再更新一下功能！！！github：https://github.com/Juenfy/vue-wechat-comment\n","categories":["前端"],"tags":["npm包"]},{"title":"基于WebRTC实现音视频通话","url":"/2025/05/22/%E5%9F%BA%E4%BA%8EWebRTC%E5%AE%9E%E7%8E%B0%E9%9F%B3%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D/","content":"WebRTC实现音视频通话最近闲暇时间（摸鱼时间很难熬）都在搞这个仿微信的项目，于是乎今天就接了个音视频通话。在线体验：https://chat.juenfy.cn已存在用户：13006789001~13006789010 密码都是123456前端项目github:https://github.com/Juenfy/cover-wechat-client后端项目github:https://github.com/Juenfy/cover-wechat-api\n客户端采用WebRTC技术（推流），通讯用websocket。\nWebRTC像是一个面试过程：第一步：拨打电话发起方（拨打电话者）点击拨打电话时，获取本地媒体流并推流给接收方同时捕获接收方推过来的流，捕获到后把流设置到dom上，监听ICE候选确保能点对连接，生成offer，通过websocket告知接收方并拉起等待接听界面。\n//获取媒体流stream.value = await navigator.mediaDevices.getUserMedia(&#123;\tvideo: true,\taudio: true&#125;);// 初始化 PeerConnectionpeerConnection.value = new RTCPeerConnection(&#123;    iceServers: [        &#123;            urls: &#x27;stun:stun.l.google.com:19302&#x27;        &#125;    ]&#125;);// 推流给接收方stream.value.getTracks().forEach((track) =&gt; &#123;\tpeerConnection.value.addTrack(track, stream.value);&#125;);// 捕获接收方的流peerConnection.value.ontrack = (event) =&gt; &#123;\tremoteStream.value = event.streams[0];\tif (callType.value === TypeVideo) &#123;\t\tremoteVideo.value.srcObject = remoteStream.value;\t&#125; else &#123;\t\tremoteAudio.value.srcObject = remoteStream.value;\t&#125;&#125;;// 监听ICE候选，确保 WebRTC 的点对点连接能够成功建立peerConnection.value.onicecandidate = (event) =&gt; &#123;\tif (event.candidate) &#123;\t\t//发送candidate\t\tws.send(event.candidate);\t&#125;&#125;;// 创建 offerconst offer = await peerConnection.value.createOffer();await peerConnection.value.setLocalDescription(offer);//发送offer，这里发送的offer可以理解成是接收方用来捕获发起方流的一个凭证，接收方通过peerConnection.value.ontrack可以捕获到。ws.send(offer);//拉起等待接听界面showCall.value = true;//状态等待接听callStatus.value = &#x27;wating&#x27;;\n\n第二步：接收电话接收方收到offer后，先拉起来电界面，再选择接听或者挂断。\n1）拉起来电接听界面//拉起来电接听界面showCall.vue = true;//状态来电接听callStatus.value = &#x27;coming&#x27;;//初始化来电人信息等....\n2）挂断告诉发起方我挂断了，发起方就把RTC关掉、停止推流，dom置空就好了\n//接收方showCall.value = false;callStatus.value = &#x27;closing&#x27;;ws.send(&#x27;reject&#x27;);//发起方if (peerConnection.value) &#123;\tpeerConnection.value.close();\tpeerConnection.value = null;&#125;if (stream.value) &#123;\tconst tracks = stream.value.getTracks();\ttracks.forEach((track) =&gt; track.stop());&#125;if (localVideo.value)\tlocalVideo.value.srcObject = null;if (remoteVideo.value)\tremoteVideo.value.srcObject = null;if (remoteAudio.value)\tremoteAudio.value.srcObject = null;showCall.value = false;callStatus.value = &#x27;closing&#x27;;\n\n2）或者接听操作跟拨打流程差不多，需要设置远端SDP（发起方的offer)，添加ICE候选（发起方的ice，这里需要注意的是只有远端SDP初始化完毕状态下才能设置ice）\n// 获取本地媒体流...同发起方// 初始化 PeerConnection...同发起方// 推流给发起方...同发起方// 捕获发起方的流...同发起方// 监听ICE候选...同发起方//设置远端SDPawait peerConnection.value.setRemoteDescription(new RTCSessionDescription(caller.value.offer));// 添加发起方发过来的iceiceCandidateQueue.value.forEach(async (candidate) =&gt; &#123;await  peerConnection.value.addIceCandidate(candidate);&#125;);iceCandidateQueue.value  = [];// 创建 answerconst  answer  =  await  peerConnection.value.createAnswer();await  peerConnection.value.setLocalDescription(answer);//发送answer给发起方ws.send(answer);//状态通话中callStatus.value = &#x27;calling&#x27;;\n关于ice的处理，就是远端SDP初始化完毕状态可以直接设置，未初始化完毕就存到iceCandidateQueue队列备用\n// 处理新的 ICE 候选const handleNewICECandidate = async (candidate) =&gt; &#123;    const iceCandidate = new RTCIceCandidate(candidate);    if (peerConnection.value?.signalingState === &#x27;have-remote-offer&#x27; || peerConnection.value?.signalingState === &#x27;stable&#x27;) &#123;        peerConnection.value.addIceCandidate(iceCandidate);    &#125; else &#123;        iceCandidateQueue.value.push(iceCandidate);    &#125;&#125;;\n3）设置远端SDP、ICE发起方收到接收方的答复（接收方接听了），设置远端SDP（接收方的answer）,设置ICE（接收方的ice）\n//设置远端SDPawait peerConnection.value.setRemoteDescription(new RTCSessionDescription(caller.value.answer));//添加ICEiceCandidateQueue.value.forEach(async (candidate) =&gt; &#123;\tawait peerConnection.value.addIceCandidate(candidate);&#125;);iceCandidateQueue.value = [];//状态接听中callStatus.value = &#x27;calling&#x27;;\n\n这就是WebRTC视频通话的关键代码跟流程！\n我的项目实现效果图：\n\n    \n\t\n\t\n","categories":["前端"],"tags":["WebRTC"]},{"title":"在博客里面添加个人开发的移动端项目演示","url":"/2025/06/13/%E5%9C%A8%E5%8D%9A%E5%AE%A2%E9%87%8C%E9%9D%A2%E6%B7%BB%E5%8A%A0%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%BC%94%E7%A4%BA/","content":"在博客里面添加个人项目演示一、准备工作1.安装一个主题，这里以主题redefine为例子传送门：Github\n2.定位修改代码的位置首选我们可以确定不能直接修改public里面生成出来的html，因为这样下次hexo generate的时候，代码会丢失，所以我们需要修改主题的模板文。可以修改这个文件，因为页面空旷的位置比较多。blog\\themes\\redefine\\layout\\pages\\home\\home-banner.ejs\n二、修改代码1. 定位div在这个文件找到.home-banner-container&gt;.content的div，直接在这个div里面添加代码即可。\n2. 添加代码如下：我这里是准备了个手机外壳的图片+iframe搞成跟手机一样的演示我的项目，最终效果就是我博客现在的这个样子。\n&lt;div class=&quot;cover-wechat-iframe-container&quot;&gt;    &lt;img src=&quot;&lt;%- url_for(theme.defaults.mobile) %&gt;&quot; alt=&quot;&quot;&gt;\t    &lt;iframe        width=&quot;375&quot;        height=&quot;735&quot;        frameborder=&quot;0&quot;        scrolling=&quot;no&quot;        style=&quot;overflow: hidden;&quot;        id=&quot;cover-wechat-iframe&quot;        &gt;    &lt;/iframe&gt;&lt;/div&gt;&lt;script&gt;    document.addEventListener(&#x27;DOMContentLoaded&#x27;, function () &#123;        let url = &#x27;http://124.71.219.151:5173&#x27;;        let coverWechatIframe = document.getElementById(&#x27;cover-wechat-iframe&#x27;);        coverWechatIframe.src = url;        document.getElementsByClassName(&#x27;tool-dark-light-toggle&#x27;)[0].addEventListener(&#x27;click&#x27;, function () &#123;            console.log(document.body.className);            if (document.body.className.indexOf(&#x27;dark&#x27;) !== -1) &#123;                coverWechatIframe.src = url + &#x27;?theme=light&#x27;;            &#125; else &#123;                coverWechatIframe.src = url + &#x27;?theme=dark&#x27;;            &#125;        &#125;);    &#125;);&lt;/script&gt;&lt;style&gt;    .cover-wechat-iframe-container &#123;        position: absolute;        top: 10px;        right: 100px;        height: 755px;        width: 395px;        z-index: 1;        display: flex;        justify-content: center;        align-items: center;    &#125;    .cover-wechat-iframe-container &gt; img &#123;        height:755px;        width: 395px;        position: absolute;        top: 0;        left: 0;    &#125;    .cover-wechat-iframe-container &gt; iframe &#123;        height: 735px;        width: 375px;        border-radius: 40px;        overflow: hidden;        z-index: 100;    &#125;    @media only screen and (max-width: 768px) &#123;        .cover-wechat-iframe-container &#123;            display: none;        &#125;    &#125;    @media only screen and (min-width: 768px) &#123;        .cover-wechat-iframe-container &#123;            display: flex;        &#125;    &#125;&lt;/style&gt;","categories":["教程","前端"],"tags":["hexo"]},{"title":"解决mui-player移动端时用不了PC端扩展的问题","url":"/2025/05/30/%E8%A7%A3%E5%86%B3mui-player%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%97%B6%E7%94%A8%E4%B8%8D%E4%BA%86PC%E7%AB%AF%E6%89%A9%E5%B1%95%E7%9A%84%E9%97%AE%E9%A2%98/","content":"解决mui-player移动端时用不了PC端扩展的问题问题描述我们都知道mui-player移动端扩展【专业版】和PC端扩展【专业版】都是要收费的。而且也没有提供移动端普通扩展，只提供了PC端普通扩展。但是当设备是移动端时，PC端扩展就用不了了，那有没有办法解决这个问题呢？答案肯定是有的。官方文档\n找到解决方法定位关键源码我们解压格式化一下mui-player.min.js的源码，找到了下面这段代码（文件搜索MuiPlayerMobilePlugin就能找到）：\nif (&quot;MuiPlayerDesktopPlugin&quot; == plugins[o].name &amp;&amp; &quot;window&quot; == $method.returnSys()) &#123;    webpagePlugin = plugins[o];    break&#125;if (&quot;MuiPlayerMobilePlugin&quot; == plugins[o].name &amp;&amp; (&quot;androd&quot; == $method.returnSys() || &quot;ios&quot; == $method.returnSys() || !0 === plugins[o].webpage)) &#123;    mobilePlugin = plugins[o];    break&#125;\n\n解读源码首先plugins[o]就是我们配置里面new出来的扩展，他是判断系统端和扩展名称决定当前应该使用哪个端的扩展的。\n下面的代码就是配置的PC端扩展：\nconst playerConfig = &#123;    plugins: [         // 添加PC端播放插件        typeof MuiPlayerDesktopPlugin == &#x27;function&#x27; ? new MuiPlayerDesktopPlugin(&#123;            name: &#x27;&#x27;,            webpage: 0,            fullScaling: 1.2,// 全屏控件缩放比例            leaveHiddenControls: true, // 鼠标指针移出播放器时是否隐藏控件            customSetting: customSetting.items, // 自定义设置组菜单            thumbnails: globals.thumbnails, // 缩略图配置            contextmenu: [ // 自定义右键菜单                &#123;                    name: &#x27;share&#x27;,                    context: &#x27;Share&#x27;,                    zIndex: 0,                    show: true,                    click: function (close) &#123;                        globals.mp.showToast(&#x27;Trigger Click！&#x27;)                        close()                    &#125;                &#125;,            ],        &#125;) : &#123;&#125;    ]&#125;\n\n解决方法\n我们在解决的同时不能修改源码，我们需要在自己的代码里面去修改并解决这个问题。\n首先源码区分了系统端，这个我们是没办法改的了，但是扩展名称我们可以修改。\n换言之，当系统不是window时，我们把扩展名称改为MuiPlayerMobilePlugin，让PC端扩展生效，这样就可以解决这个问题了。\n\n解决代码\n先拷贝源码里判断系统端代码（$method.returnSys()），用来我们自己判断系统端：\n\nexport const returnSys = () =&gt; &#123;    var e = new function() &#123;        var e = navigator.userAgent;        navigator.appVersion;        return &#123;            ios: !!e.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/),            android: -1 &lt; e.indexOf(&quot;Android&quot;) || -1 &lt; e.indexOf(&quot;Linux&quot;),            iPhone: -1 &lt; e.indexOf(&quot;iPhone&quot;),            iPad: -1 &lt; e.indexOf(&quot;iPad&quot;)        &#125;    &#125;;    return e.iPhone || e.iPad || e.ios ? &quot;ios&quot; : e.android ? &quot;androd&quot; : &quot;window&quot;&#125;\n\n\n在实例化MuiPlayer前，当系统不是window时，把配置里的扩展名称改为MuiPlayerMobilePlugin。\n\nif (returnSys() !== &#x27;window&#x27; &amp;&amp; playerConfig.plugins.length &gt; 0) &#123;playerConfig.plugins[0].name = &#x27;MuiPlayerMobilePlugin&#x27;&#125;new MuiPlayer(playerConfig)\n\n\nchrome F12打开控制台，更换设备工具，选择手机，刷新页面，PC端扩展照样能正常使用。\n\n","categories":["教程"],"tags":["mui-player"]},{"title":"使用Hexo搭建静态博客并部署到GitHubPages","url":"/2025/06/18/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0GitHubPages/","content":"使用 Hexo 搭建静态博客并部署到 GitHub Pages这是我搭建的博客\n一、环境准备1.安装 Node.jsHexo 基于 Node.js，需先安装：\n# Ubuntu/Debiansudo apt updatesudo apt install nodejs npm# macOS（通过 Homebrew）brew install node# 验证安装node -vnpm -v# 安装国内淘宝镜像npm install -g cnpm# 验证安装cnpm -v\nwindows直接安装nodejs msi\n2.安装Git# Ubuntu/Debiansudo apt install gitgit --version\nwindows直接安装git for windows\n3.安装 Hexocnpm install -g hexo-clihexo -v  # 验证安装\n\n二、初始化 Hexo 博客1.创建项目目录hexo init blogcd blog\n2.安装依赖cnpm install\n3.安装主题git clone https://github.com/EvanNotFound/hexo-theme-redefine.git themes/redefine\n修改博客目录下的 _config.yml 文件，使用redefine主题:\n# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: redefine\n4.本地预览hexo server #或 hexo s\n\n三、配置 GitHub Pages1.创建 GitHub 仓库仓库名必须为 username.github.io（如 Juenfy.github.io）。选择 Public 可见性，初始化时可跳过 .gitignore 和 README。\n2.配置 Hexo 部署设置修改博客目录下的 _config.yml 文件：\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: https://github.com/Juenfy/Juenfy.github.io.git  branch: master\n3.安装部署插件cnpm install hexo-deployer-git --save\n\n四、撰写与发布文章1.新建文章hexo new &quot;Hello World&quot; # 在 source/_posts 下生成 Hello World.md Markdown文件\n2.编辑文章用 Markdown 语法编写内容（支持 Front-matter 配置）：\n---title: Hello Worlddate: 2025-06-18 15:59:04tags:- 标签1- 标签2categories- 分类1- 分类2---这里是正文内容...\n3.生成静态文件hexo generate  # 或 hexo g\n4.部署到 GitHubhexo deploy  # 或 hexo d\n\n部署完后通过username.github.io访问即可。\n","categories":["教程"],"tags":["hexo"]}]