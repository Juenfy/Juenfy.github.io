[{"title":"基于WebRTC实现音视频通话","url":"/2025/05/22/%E5%9F%BA%E4%BA%8EWebRTC%E5%AE%9E%E7%8E%B0%E9%9F%B3%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D/","content":"最近闲暇时间（摸鱼时间很难熬）都在搞这个仿微信的项目，于是乎今天就接了个音视频通话。在线体验：https://chat.juenfy.cn已存在用户：13006789001~13006789010 密码都是123456前端项目github:https://github.com/Juenfy/cover-wechat-client后端项目github:https://github.com/Juenfy/cover-wechat-api\n客户端采用WebRTC技术（推流），通讯用websocket。\nWebRTC像是一个面试过程：第一步：发起方（拨打电话者）点击拨打电话时，获取本地媒体流并推流给接收方同时捕获接收方推过来的流，捕获到后把流设置到dom上，监听ICE候选确保能点对连接，生成offer，通过websocket告知接收方并拉起等待接听界面。\n//获取媒体流stream.value = await navigator.mediaDevices.getUserMedia(&#123;\tvideo: true,\taudio: true&#125;);// 初始化 PeerConnectionpeerConnection.value = new RTCPeerConnection(&#123;    iceServers: [        &#123;            urls: &#x27;stun:stun.l.google.com:19302&#x27;        &#125;    ]&#125;);// 推流给接收方stream.value.getTracks().forEach((track) =&gt; &#123;\tpeerConnection.value.addTrack(track, stream.value);&#125;);// 捕获接收方的流peerConnection.value.ontrack = (event) =&gt; &#123;\tremoteStream.value = event.streams[0];\tif (callType.value === TypeVideo) &#123;\t\tremoteVideo.value.srcObject = remoteStream.value;\t&#125; else &#123;\t\tremoteAudio.value.srcObject = remoteStream.value;\t&#125;&#125;;// 监听ICE候选，确保 WebRTC 的点对点连接能够成功建立peerConnection.value.onicecandidate = (event) =&gt; &#123;\tif (event.candidate) &#123;\t\t//发送candidate\t\tws.send(event.candidate);\t&#125;&#125;;// 创建 offerconst offer = await peerConnection.value.createOffer();await peerConnection.value.setLocalDescription(offer);//发送offer，这里发送的offer可以理解成是接收方用来捕获发起方流的一个凭证，接收方通过peerConnection.value.ontrack可以捕获到。ws.send(offer);//拉起等待接听界面showCall.value = true;//状态等待接听callStatus.value = &#x27;wating&#x27;;\n\n第二步：接收方收到offer后，第一步是拉起来电界面，第二步是选择接听或者挂断。1）拉起来电接听界面\n//拉起来电接听界面showCall.vue = true;//状态来电接听callStatus.value = &#x27;coming&#x27;;//初始化来电人信息等....\n2）挂断，就是告诉发起方我挂断了，发起方就把RTC关掉、停止推流，dom置空就好了\n//接收方showCall.value = false;callStatus.value = &#x27;closing&#x27;;ws.send(&#x27;reject&#x27;);//发起方if (peerConnection.value) &#123;\tpeerConnection.value.close();\tpeerConnection.value = null;&#125;if (stream.value) &#123;\tconst tracks = stream.value.getTracks();\ttracks.forEach((track) =&gt; track.stop());&#125;if (localVideo.value)\tlocalVideo.value.srcObject = null;if (remoteVideo.value)\tremoteVideo.value.srcObject = null;if (remoteAudio.value)\tremoteAudio.value.srcObject = null;showCall.value = false;callStatus.value = &#x27;closing&#x27;;\n\n2）接听，操作跟拨打流程差不多，需要设置远端SDP（发起方的offer)，添加ICE候选（发起方的ice，这里需要注意的是只有远端SDP初始化完毕状态下才能设置ice）\n// 获取本地媒体流...同发起方// 初始化 PeerConnection...同发起方// 推流给发起方...同发起方// 捕获发起方的流...同发起方// 监听ICE候选...同发起方//设置远端SDPawait peerConnection.value.setRemoteDescription(new RTCSessionDescription(caller.value.offer));// 添加发起方发过来的iceiceCandidateQueue.value.forEach(async (candidate) =&gt; &#123;await  peerConnection.value.addIceCandidate(candidate);&#125;);iceCandidateQueue.value  = [];// 创建 answerconst  answer  =  await  peerConnection.value.createAnswer();await  peerConnection.value.setLocalDescription(answer);//发送answer给发起方ws.send(answer);//状态通话中callStatus.value = &#x27;calling&#x27;;\n关于ice的处理，就是远端SDP初始化完毕状态可以直接设置，未初始化完毕就存到iceCandidateQueue队列备用\n// 处理新的 ICE 候选const handleNewICECandidate = async (candidate) =&gt; &#123;    const iceCandidate = new RTCIceCandidate(candidate);    if (peerConnection.value?.signalingState === &#x27;have-remote-offer&#x27; || peerConnection.value?.signalingState === &#x27;stable&#x27;) &#123;        peerConnection.value.addIceCandidate(iceCandidate);    &#125; else &#123;        iceCandidateQueue.value.push(iceCandidate);    &#125;&#125;;\n最后一步：发起方收到接收方的答复（接收方接听了），设置远端SDP（接收方的answer）,设置ICE（接受方的ice）\n//设置远端SDPawait peerConnection.value.setRemoteDescription(new RTCSessionDescription(caller.value.answer));//添加ICEiceCandidateQueue.value.forEach(async (candidate) =&gt; &#123;\tawait peerConnection.value.addIceCandidate(candidate);&#125;);iceCandidateQueue.value = [];//状态接听中callStatus.value = &#x27;calling&#x27;;\n\n这就是WebRTC视频通话的关键代码跟流程！\n我的项目实现效果图：\n","categories":["前端"],"tags":["WebRTC"]}]